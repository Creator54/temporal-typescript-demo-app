# Temporal Hello World with OpenTelemetry (Java -> Go/TypeScript Port Guide)
This context file provides exact details needed to port the Java implementation to Go/TypeScript while maintaining identical functionality, naming, and observability.

## Project Overview
A minimal Temporal application demonstrating workflow orchestration with OpenTelemetry integration for metrics and tracing using SigNoz.

## Directory Structure
```
/src/
└── main/
    └── helloworld/
        ├── config/
        │   ├── TemporalConfig.java           # Temporal connection configuration
        │   ├── SignozTelemetryUtils.java     # Main telemetry coordinator
        │   ├── OpenTelemetryConfig.java      # OTel configuration
        │   ├── MetricsExporter.java          # Metrics setup
        │   └── TracingExporter.java          # Tracing setup
        ├── workflows/
        │   ├── HelloWorldWorkflow.java       # Workflow interface
        │   └── impl/
        │       └── HelloWorldWorkflowImpl.java  # Workflow implementation
        ├── workers/
        │   └── HelloWorldWorker.java         # Worker process implementation
        └── main/
            └── HelloWorldStarter.java        # Workflow starter
```

## Environment Variables

### 1. Temporal Configuration
```bash
# Required for Temporal Cloud
TEMPORAL_HOST_URL="localhost:7233"              # Default for local
TEMPORAL_NAMESPACE="default"                    # Default namespace
TEMPORAL_TASK_QUEUE="hello-world-task-queue"   # Default task queue
TEMPORAL_TLS_CERT="<path-to-certificate.pem>"  # Required for cloud
TEMPORAL_TLS_KEY="<path-to-private-key.key>"   # Required for cloud
```

### 2. SigNoz/OpenTelemetry Configuration
```bash
OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"  # Default endpoint
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-token>"
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world,environment=development"
```

## Core Components

### 1. Workflow Definition
```
Interface: HelloWorldWorkflow
Method: sayHello(String name)
Return: String format "Hello {name}!"
Task Queue: "hello-world-task-queue"
Workflow Type: "HelloWorldWorkflow"
Workflow Method: "sayHello"
```

### 2. OpenTelemetry Configuration
```
Protocol: OTLP/gRPC
Default Endpoint: http://localhost:4317
Service Name: temporal-hello-world
Environment: development
Propagators: tracecontext,baggage
Sampling: ALWAYS_ON
```

### 3. Metrics Configuration
- Export Interval: 5 seconds
- Exporter Timeout: 60 seconds
- Shutdown Timeout: 10 seconds
- Scope Type: NoopScope for Tally metrics

### 4. Tracing Configuration
- Span Context: OpenTracingSpanContextCodec.TEXT_MAP_CODEC
- Batch Processing:
  * Schedule Delay: 100ms
  * Queue Size: 2048
  * Batch Size: 512
  * Export Timeout: 30 seconds
- Shutdown Timeout: 30 seconds

### 5. Worker Configuration
- Graceful Shutdown: 3 seconds timeout
- Force Shutdown: 2 seconds timeout
- Interceptors:
  * Worker: OpenTracingWorkerInterceptor
  * Client: OpenTracingClientInterceptor

## Exact Names and Identifiers

### 1. Workflow Names
```
Workflow Interface: "HelloWorldWorkflow"
Workflow Implementation: "HelloWorldWorkflowImpl"
Task Queue: "hello-world-task-queue"
Workflow ID Format: "hello-world-{UUID}"
Workflow Run ID Format: Generated by Temporal
```

### 2. Span Names and Attributes
```
Workflow Starter Spans:
- StartWorkflow
  * workflow.name: "HelloWorldWorkflow"
  * workflow.input: "${input_name}"
  * workflow.type: "temporal"
  * service.name: "temporal-hello-world"
  * workflow.id: "${workflow_id}"
  * workflow.task_queue: "${task_queue}"
  * workflow.attempt: 1

- ExecuteWorkflow
  * workflow.id: "${workflow_id}"
  * workflow.type: "temporal"
  * service.name: "temporal-hello-world"
  * workflow.task_queue: "${task_queue}"
  * workflow.result: "${result}"

Workflow Spans:
- temporal.workflow.start
  * workflow.type: "HelloWorldWorkflow"
  * workflow.method: "sayHello"
  * workflow.task_queue: "hello-world-task-queue"
  * workflow.namespace: "${TEMPORAL_NAMESPACE}"

- temporal.workflow.execute
  * workflow.type: "HelloWorldWorkflow"
  * workflow.method: "sayHello"
  * workflow.task_queue: "hello-world-task-queue"

- temporal.workflow.complete
  * workflow.type: "HelloWorldWorkflow"
  * workflow.status: "completed"

Worker Spans:
- temporal.worker.start
  * worker.task_queue: "hello-world-task-queue"
  * worker.type: "HelloWorldWorker"

- temporal.worker.poll
  * worker.task_queue: "hello-world-task-queue"
  * worker.type: "HelloWorldWorker"
```

### 3. Metric Names
```
Workflow Metrics:
- temporal_workflow_completed
  * workflow_type: "HelloWorldWorkflow"
  * status: "completed"

- temporal_workflow_started
  * workflow_type: "HelloWorldWorkflow"

Worker Metrics:
- temporal_worker_task_slots_available
  * task_queue: "hello-world-task-queue"

- temporal_worker_task_slots_total
  * task_queue: "hello-world-task-queue"

- temporal_worker_start_counter
  * task_queue: "hello-world-task-queue"

Common Tags for Metrics:
- service: "temporal-hello-world"
- environment: "development"
- namespace: "${TEMPORAL_NAMESPACE}"
```

### 4. Resource Attributes
```
Common Resource Attributes:
- service.name: "temporal-hello-world"
- service.namespace: "${TEMPORAL_NAMESPACE}"
- service.instance.id: "${HOSTNAME}"
- environment: "development"

Workflow-specific:
- temporal.workflow.type: "HelloWorldWorkflow"
- temporal.workflow.method: "sayHello"
- temporal.task_queue: "hello-world-task-queue"

Worker-specific:
- temporal.worker.type: "HelloWorldWorker"
- temporal.task_queue: "hello-world-task-queue"
```

### 5. Retry Configuration
```
Workflow Retry Options:
- Initial Interval: 1 second
- Maximum Interval: 10 seconds
- Backoff Coefficient: 2.0
- Maximum Attempts: 3

Error Handling:
- Status Code OK: Successful completion
- Status Code ERROR: Exception encountered
- Exception Recording: Full stack trace
```

### 6. Workflow Options
```
WorkflowOptions:
- Task Queue: ${TEMPORAL_TASK_QUEUE}
- Workflow ID: "hello-world-" + UUID.randomUUID()
- Retry Options: As specified above
```

## Implementation Details

### 1. Workflow Starter
```
Components:
- WorkflowClient with telemetry interceptors
- OpenTelemetry tracer for custom spans
- Retry policy configuration
- Error handling and logging
- Automatic span management

Initialization Sequence:
1. Initialize OpenTelemetry
2. Configure service stubs with metrics
3. Setup client with interceptors
4. Create workflow client

Execution Flow:
1. Create parent span (StartWorkflow)
2. Generate unique workflow ID
3. Configure workflow options
4. Create workflow stub
5. Create child span (ExecuteWorkflow)
6. Execute workflow
7. Handle result/errors
8. End spans
9. Force flush telemetry
```

### 2. Error Handling
```
Error Scenarios:
1. Workflow Execution:
   - Record exception in span
   - Set ERROR status
   - Propagate error
   - End spans properly

2. Client Creation:
   - Log error
   - Exit with status 1

3. Telemetry:
   - Log warning
   - Continue execution
```

## Shutdown Sequence
1. Worker Factory (3s timeout)
2. Service Connections
3. Force Shutdown if needed (2s)
4. Metrics Pipeline (10s)
5. Tracing Pipeline (30s)

## Configuration Priority

### Temporal Connection
1. Cloud Setup (if TEMPORAL_HOST_URL + TLS certs exist)
2. Local Setup (localhost:7233)

### SigNoz Connection
1. Cloud (if OTEL_EXPORTER_OTLP_HEADERS has token)
2. Custom (if OTEL_EXPORTER_OTLP_ENDPOINT set)
3. Local (http://localhost:4317)

## Implementation Notes

### 1. Workflow
- Simple string concatenation
- Prepared for activity extension
- Workflow interface must match exactly

### 2. Worker
- Single task queue subscription
- Graceful shutdown required
- Must integrate telemetry

### 3. Telemetry
- Initialize before Temporal client
- Support custom instrumentation
- Maintain exact metric/span names

## Critical Compatibility Points
1. All service names must match exactly
2. Metric and span names must be identical
3. Resource attributes must match
4. Environment variable names must be preserved
5. Shutdown sequence must be maintained
6. Task queue and workflow names must be identical
7. Trace context propagation must be compatible
8. Logging format must match exactly
9. Shutdown timeouts must be identical
10. Worker options must maintain same limits
11. Error handling patterns must be consistent

## Port Verification Checklist
- [ ] Workflow names match in Temporal UI
- [ ] Metrics appear identical in SigNoz
- [ ] Traces show same structure and names
- [ ] Environment variables work without changes
- [ ] Resource attributes match exactly
- [ ] Shutdown behavior is identical
- [ ] TLS configuration works for cloud setup 

## Critical Implementation Details for Span Handling

### 1. Span Creation Rules
```
1. Spans MUST only be created in the workflow starter
2. Do NOT use OpenTelemetry interceptors in workers
3. Maintain exact span hierarchy:
   StartWorkflow
   └── ExecuteWorkflow
       └── StartWorkflow:HelloWorldWorkflow

Span Timing (approximate):
- StartWorkflow: ~1.25s (parent span)
- ExecuteWorkflow: ~1.23s (child of StartWorkflow)
- StartWorkflow:HelloWorldWorkflow: ~200ms (child of ExecuteWorkflow)
```

### 2. Common Issues to Avoid
```
1. Double Span Creation:
   - DON'T use OpenTelemetry interceptors with manual span creation
   - DON'T create spans in both worker and starter
   - DON'T create spans in workflow implementation

2. Incorrect Span Hierarchy:
   - ALWAYS create spans in the correct order
   - ENSURE proper parent-child relationships
   - USE the context properly for span propagation

3. Naming Conflicts:
   - STICK to exact span names from Java implementation
   - DON'T add additional spans
   - DON'T modify span names

4. Attribute Consistency:
   - MAINTAIN exact attribute names and values
   - ENSURE all required attributes are present
   - DON'T add extra attributes
```

### 3. Span Creation Location
```
Correct:
- Workflow Starter: All span creation and management
- Worker: No span creation, just workflow execution
- Activity: No span creation, just business logic

Incorrect:
- Creating spans in worker configuration
- Using OpenTelemetry interceptors
- Creating spans in workflow implementation
```

### 4. Context Propagation
```
1. Context Flow:
   - Start with base context from main
   - Pass through span creation chain
   - Maintain context through workflow execution

2. Span Lifecycle:
   - Create spans in correct order
   - Defer span.End() in reverse order
   - Ensure proper cleanup
```

### 5. TypeScript-Specific Considerations
```
1. Span Creation:
   - Use @opentelemetry/api for span creation
   - Avoid @temporalio/interceptors for spans
   - Maintain manual span creation in starter

2. Context Handling:
   - Use Context from @opentelemetry/api
   - Ensure proper async/await with spans
   - Handle promise chains carefully

3. Cleanup:
   - Use try/finally for span cleanup
   - Ensure spans are ended in reverse order
   - Handle async operations properly
```

### 6. Testing Span Implementation
```
Verification Steps:
1. Check span names match exactly
2. Verify span hierarchy is correct
3. Confirm span timing patterns
4. Validate all attributes are present
5. Ensure no duplicate spans
6. Test context propagation
```

## Recommended Go Project Structure
```
/cmd/
└── helloworld/
    └── main.go                    # Entry point (keeps main separate)

/internal/
└── helloworld/                    # Main package namespace
    ├── config/
    │   ├── temporal.go            # Temporal connection config
    │   ├── telemetry.go          # Main telemetry coordinator
    │   ├── otel.go               # OpenTelemetry config
    │   ├── metrics.go            # Metrics setup
    │   └── tracing.go            # Tracing setup
    ├── workflow/
    │   ├── interface.go          # Workflow interface
    │   └── impl/
    │       └── hello_world.go    # Workflow implementation
    ├── worker/
    │   └── worker.go             # Worker process
    └── starter/
        └── starter.go            # Workflow starter

/pkg/                             # Shared/public packages if needed
└── telemetry/                    # Reusable telemetry components
    └── propagator/
        └── propagator.go         # Context propagation utilities

Rationale for Structure:
1. /cmd/ - Standard Go practice for executable entry points
2. /internal/ - Enforces package privacy, matches Java's src/main
3. /pkg/ - For potentially reusable components
4. Separate config files - Matches Java's granular configuration
5. Clear package boundaries - Similar to Java package structure

Key Differences from Java:
1. Use of /cmd/ and /internal/ - Go community standards
2. Flatter hierarchy - Go preference
3. Shorter file names - Go convention
4. Package-oriented - Go's module system

Migration Notes:
1. Move main.go to /cmd/helloworld/
2. Restructure telemetry into separate config files
3. Use internal/helloworld as base package
4. Keep workflow interface separate from implementation
```

## Go Implementation Details to Match in TypeScript

### 1. Worker Configuration
```typescript
// Match these exact worker options from Go
workerOptions = {
  maxConcurrentActivityExecutionSize: 20,  // Maintain this exact limit
  enableLoggingInReplay: true,            // Keep replay logging enabled
}
```

### 2. Logging Format
```
[WORKER] YYYY/MM/DD HH:mm:ss.SSSSSS [LEVEL] Message
[WORKFLOW] YYYY/MM/DD HH:mm:ss.SSSSSS [LEVEL] Message
```

### 3. Shutdown Sequence Timing
- Worker graceful shutdown: 5 seconds timeout
- OpenTelemetry shutdown: 5 seconds timeout
- Force shutdown after timeouts

### 4. OpenTelemetry Configuration
```typescript
// Match these exact configurations
const otelConfig = {
  metricExportInterval: 10 * 1000,      // 10 seconds
  spanBatchTimeout: 5 * 1000,           // 5 seconds
  maxExportBatchSize: 512,
  maxQueueSize: 2048,
  retryConfig: {
    initialInterval: 1000,              // 1 second
    maxInterval: 5000,                  // 5 seconds
    maxElapsedTime: 30000              // 30 seconds
  }
}
```

### 5. Error Handling
- Workflow execution timeout: 30 seconds
- Graceful shutdown on SIGINT/SIGTERM
- Proper cleanup of resources in reverse order
- Clear error messages with prefixes

### 6. Start Script Features
- Color-coded output
- Service health checks
- Worker initialization verification
- Graceful shutdown handling
- Environment variable configuration

## Critical Compatibility Points
1. All service names must match exactly
2. Metric and span names must be identical
3. Resource attributes must match
4. Environment variable names must be preserved
5. Shutdown sequence must be maintained
6. Task queue and workflow names must be identical
7. Trace context propagation must be compatible
8. Logging format must match exactly
9. Shutdown timeouts must be identical
10. Worker options must maintain same limits
11. Error handling patterns must be consistent

## Port Verification Checklist
- [ ] Workflow names match in Temporal UI
- [ ] Metrics appear identical in SigNoz
- [ ] Traces show same structure and names
- [ ] Environment variables work without changes
- [ ] Resource attributes match exactly
- [ ] Shutdown behavior is identical
- [ ] TLS configuration works for cloud setup 

## Critical Implementation Details for Span Handling

### 1. Span Creation Rules
```
1. Spans MUST only be created in the workflow starter
2. Do NOT use OpenTelemetry interceptors in workers
3. Maintain exact span hierarchy:
   StartWorkflow
   └── ExecuteWorkflow
       └── StartWorkflow:HelloWorldWorkflow

Span Timing (approximate):
- StartWorkflow: ~1.25s (parent span)
- ExecuteWorkflow: ~1.23s (child of StartWorkflow)
- StartWorkflow:HelloWorldWorkflow: ~200ms (child of ExecuteWorkflow)
```

### 2. Common Issues to Avoid
```
1. Double Span Creation:
   - DON'T use OpenTelemetry interceptors with manual span creation
   - DON'T create spans in both worker and starter
   - DON'T create spans in workflow implementation

2. Incorrect Span Hierarchy:
   - ALWAYS create spans in the correct order
   - ENSURE proper parent-child relationships
   - USE the context properly for span propagation

3. Naming Conflicts:
   - STICK to exact span names from Java implementation
   - DON'T add additional spans
   - DON'T modify span names

4. Attribute Consistency:
   - MAINTAIN exact attribute names and values
   - ENSURE all required attributes are present
   - DON'T add extra attributes
```

### 3. Span Creation Location
```
Correct:
- Workflow Starter: All span creation and management
- Worker: No span creation, just workflow execution
- Activity: No span creation, just business logic

Incorrect:
- Creating spans in worker configuration
- Using OpenTelemetry interceptors
- Creating spans in workflow implementation
```

### 4. Context Propagation
```
1. Context Flow:
   - Start with base context from main
   - Pass through span creation chain
   - Maintain context through workflow execution

2. Span Lifecycle:
   - Create spans in correct order
   - Defer span.End() in reverse order
   - Ensure proper cleanup
```

### 5. TypeScript-Specific Considerations
```
1. Span Creation:
   - Use @opentelemetry/api for span creation
   - Avoid @temporalio/interceptors for spans
   - Maintain manual span creation in starter

2. Context Handling:
   - Use Context from @opentelemetry/api
   - Ensure proper async/await with spans
   - Handle promise chains carefully

3. Cleanup:
   - Use try/finally for span cleanup
   - Ensure spans are ended in reverse order
   - Handle async operations properly
```

### 6. Testing Span Implementation
```
Verification Steps:
1. Check span names match exactly
2. Verify span hierarchy is correct
3. Confirm span timing patterns
4. Validate all attributes are present
5. Ensure no duplicate spans
6. Test context propagation
```

## Recommended Go Project Structure
```
/cmd/
└── helloworld/
    └── main.go                    # Entry point (keeps main separate)

/internal/
└── helloworld/                    # Main package namespace
    ├── config/
    │   ├── temporal.go            # Temporal connection config
    │   ├── telemetry.go          # Main telemetry coordinator
    │   ├── otel.go               # OpenTelemetry config
    │   ├── metrics.go            # Metrics setup
    │   └── tracing.go            # Tracing setup
    ├── workflow/
    │   ├── interface.go          # Workflow interface
    │   └── impl/
    │       └── hello_world.go    # Workflow implementation
    ├── worker/
    │   └── worker.go             # Worker process
    └── starter/
        └── starter.go            # Workflow starter

/pkg/                             # Shared/public packages if needed
└── telemetry/                    # Reusable telemetry components
    └── propagator/
        └── propagator.go         # Context propagation utilities

Rationale for Structure:
1. /cmd/ - Standard Go practice for executable entry points
2. /internal/ - Enforces package privacy, matches Java's src/main
3. /pkg/ - For potentially reusable components
4. Separate config files - Matches Java's granular configuration
5. Clear package boundaries - Similar to Java package structure

Key Differences from Java:
1. Use of /cmd/ and /internal/ - Go community standards
2. Flatter hierarchy - Go preference
3. Shorter file names - Go convention
4. Package-oriented - Go's module system

Migration Notes:
1. Move main.go to /cmd/helloworld/
2. Restructure telemetry into separate config files
3. Use internal/helloworld as base package
4. Keep workflow interface separate from implementation
```

## TypeScript Project Structure
```
/src/
├── config/
│   ├── temporalConfig.ts         # Temporal connection configuration
│   ├── signozTelemetryUtils.ts   # Main telemetry coordinator
│   ├── openTelemetryConfig.ts    # OTel configuration
│   ├── metricsExporter.ts        # Metrics setup
│   └── tracingExporter.ts        # Tracing setup
├── workflows/
│   ├── helloWorldWorkflow.ts     # Workflow interface and implementation
│   └── index.ts                  # Workflow exports
├── workers/
│   └── helloWorldWorker.ts       # Worker process implementation
├── starter/
│   └── helloWorldStarter.ts      # Workflow starter
└── main.ts                       # Entry point

/scripts/
└── start.sh                      # Application startup script

/tests/
├── unit/                         # Unit tests
└── integration/                  # Integration tests

package.json                      # Node.js package configuration
tsconfig.json                    # TypeScript configuration
```

## TypeScript Implementation Details

### 1. Package Dependencies
```json
{
  "dependencies": {
    "@temporalio/client": "^1.8.0",
    "@temporalio/worker": "^1.8.0",
    "@temporalio/workflow": "^1.8.0",
    "@opentelemetry/api": "^1.4.0",
    "@opentelemetry/core": "^1.9.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.35.0",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.35.0",
    "@opentelemetry/resources": "^1.9.0",
    "@opentelemetry/sdk-metrics": "^1.9.0",
    "@opentelemetry/sdk-trace-base": "^1.9.0",
    "@opentelemetry/semantic-conventions": "^1.9.0"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "typescript": "^4.9.0",
    "ts-node": "^10.9.0"
  }
}
```

### 2. TypeScript Configuration
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "strict": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### 3. Workflow Implementation
```typescript
import { proxyActivities } from '@temporalio/workflow';

// Activity interface
interface HelloWorldActivities {
  sayHello(name: string): Promise<string>;
}

const { sayHello } = proxyActivities<HelloWorldActivities>({
  startToCloseTimeout: '30 seconds',
});

export async function helloWorldWorkflow(name: string): Promise<string> {
  return await sayHello(name);
}
```

### 4. Worker Configuration
```typescript
import { Worker } from '@temporalio/worker';
import * as activities from './activities';

const workerOptions = {
  maxConcurrentActivityExecutionSize: 20,
  enableLoggingInReplay: true,
};

export async function startWorker(): Promise<Worker> {
  const worker = await Worker.create({
    workflowsPath: require.resolve('./workflows'),
    activities,
    taskQueue: 'hello-world-task-queue',
    ...workerOptions,
  });

  await worker.run();
  return worker;
}
```

### 5. OpenTelemetry Setup
```typescript
import { NodeSDK } from '@opentelemetry/sdk-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

export async function initTelemetry(): Promise<() => Promise<void>> {
  const sdk = new NodeSDK({
    resource: new Resource({
      [SemanticResourceAttributes.SERVICE_NAME]: 'temporal-hello-world',
      [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: 'development',
    }),
    traceExporter: new OTLPTraceExporter({
      url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT,
      headers: parseHeaders(process.env.OTEL_EXPORTER_OTLP_HEADERS),
    }),
    metricExporter: new OTLPMetricExporter({
      url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT,
      headers: parseHeaders(process.env.OTEL_EXPORTER_OTLP_HEADERS),
    }),
  });

  await sdk.start();
  return () => sdk.shutdown();
}
```

### 6. TypeScript-Specific Considerations
```typescript
// 1. Async/Await Handling
- Use Promise.all for parallel operations
- Proper error handling with try/catch/finally
- Async cleanup in shutdown handlers

// 2. Type Safety
- Use strict TypeScript configuration
- Define interfaces for all activities
- Proper type definitions for metrics and traces

// 3. Module Structure
- Use ES modules (import/export)
- Separate concerns into modules
- Clear dependency management

// 4. Testing
- Jest for unit testing
- Integration tests with real Temporal
- Mock OpenTelemetry for testing
``` 